#!/usr/bin/env python3
from __future__ import annotations
import sys, time
from pathlib import Path

from lib.paths import config_path, state_path
from lib.config import Config
from lib.state import State, rollover_if_needed, now_epoch, clamp_delta
from lib.timefmt import hms

USAGE = """dailyquota - CLI

Commands:
  dailyquota status           Show used/remaining today
  dailyquota remaining        Print remaining time (HH:MM:SS) and exit 0
  dailyquota remaining --s    Print remaining seconds (integer)
  dailyquota set 2h|120m|7200 Set daily limit (writes config)
  dailyquota reset            Reset today's counter to 0 (edits state)
"""

def parse_duration(s: str) -> int:
    s = s.strip().lower()
    if s.isdigit():
        return int(s)
    # formats: 2h, 120m, 30s
    mul = 1
    if s.endswith("h"):
        mul = 3600
        s = s[:-1]
    elif s.endswith("m"):
        mul = 60
        s = s[:-1]
    elif s.endswith("s"):
        mul = 1
        s = s[:-1]
    if not s.isdigit():
        raise ValueError("bad duration")
    return int(s) * mul

def write_limit(limit: int) -> None:
    p = config_path()
    p.parent.mkdir(parents=True, exist_ok=True)
    # preserve existing settings if present
    existing = p.read_text(encoding="utf-8") if p.exists() else ""
    lines = []
    found = False
    for line in existing.splitlines():
        if line.strip().startswith("limit_seconds="):
            lines.append(f"limit_seconds={limit}")
            found = True
        else:
            lines.append(line)
    if not found:
        if lines and lines[-1].strip() != "":
            lines.append("")
        lines.append(f"limit_seconds={limit}")
    p.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")

def effective_used(cfg: Config, st: State) -> int:
    rollover_if_needed(st)
    now = now_epoch()
    delta = clamp_delta(now - st.last_ts, cfg.poll_seconds * 4)
    return int(st.used_seconds + delta)

def main(argv: list[str]) -> int:
    if len(argv) < 2:
        sys.stderr.write(USAGE)
        return 2

    cmd = argv[1]
    cfg = Config.load(config_path())
    st = State.load(state_path())

    if cmd == "status":
        used = effective_used(cfg, st)
        rem = max(0, cfg.limit_seconds - used)
        sys.stdout.write(f"remaining {hms(rem)} (used {hms(used)} / {hms(cfg.limit_seconds)})\n")
        return 0

    if cmd == "remaining":
        used = effective_used(cfg, st)
        rem = max(0, cfg.limit_seconds - used)
        if len(argv) >= 3 and argv[2] == "--s":
            sys.stdout.write(str(rem) + "\n")
        else:
            sys.stdout.write(hms(rem) + "\n")
        return 0

    if cmd == "set":
        if len(argv) < 3:
            sys.stderr.write("dailyquota set requires a value like 2h, 120m, or 7200\n")
            return 2
        try:
            limit = parse_duration(argv[2])
        except Exception:
            sys.stderr.write("invalid duration; use 2h, 120m, 7200, etc.\n")
            return 2
        if limit <= 0:
            sys.stderr.write("limit must be > 0\n")
            return 2
        write_limit(limit)
        sys.stdout.write(f"set limit_seconds={limit}\n")
        return 0

    if cmd == "reset":
        st = State.fresh()
        st.save(state_path())
        sys.stdout.write("reset: used_seconds=0\n")
        return 0

    sys.stderr.write(USAGE)
    return 2

if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
