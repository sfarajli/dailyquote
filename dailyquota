#!/usr/bin/env python3
from __future__ import annotations
import os, time, json
from pathlib import Path
from typing import Dict

APP = "dailyquota"

def today() -> str:
    return time.strftime("%Y-%m-%d", time.localtime())

def now() -> int:
    return int(time.time())

def config_path() -> Path:
    xdg = os.environ.get("XDG_CONFIG_HOME")
    base = Path(xdg) if xdg else (Path.home() / ".config")
    return base / APP / "config.conf"

def state_path() -> Path:
    xdg = os.environ.get("XDG_DATA_HOME")
    base = Path(xdg) if xdg else (Path.home() / ".local" / "share")
    return base / APP / "state.json"

def parse_kv(path: Path) -> Dict[str, str]:
    if not path.exists():
        return {}
    out: Dict[str, str] = {}
    for line in path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        out[k.strip()] = v.strip()
    return out

def geti(d: Dict[str, str], k: str, default: int) -> int:
    try:
        return int(d.get(k, str(default)))
    except Exception:
        return default

def gets(d: Dict[str, str], k: str, default: str) -> str:
    v = d.get(k)
    return v if v is not None and v != "" else default

def atomic_write(path: Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    tmp = path.with_suffix(path.suffix + ".tmp")
    tmp.write_text(text, encoding="utf-8")
    os.replace(tmp, path)

def load_state() -> dict:
    p = state_path()
    if not p.exists():
        return {"date": today(), "used": 0, "last": now(), "locked_date": ""}
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        return {"date": today(), "used": 0, "last": now(), "locked_date": ""}

def save_state(st: dict) -> None:
    atomic_write(state_path(), json.dumps(st, indent=2) + "\n")

def rollover(st: dict) -> dict:
    if st.get("date") != today():
        return {"date": today(), "used": 0, "last": now(), "locked_date": ""}
    return st

def hms(sec: int) -> str:
    sec = max(0, int(sec))
    return f"{sec//3600:02d}:{(sec%3600)//60:02d}:{sec%60:02d}"

import sys

USAGE = """dailyquota

Commands:
  dailyquota remaining        Print remaining (HH:MM:SS)
  dailyquota remaining --s    Print remaining seconds
  dailyquota status           Print used/remaining/limit
"""

def main(argv: list[str]) -> int:
    if len(argv) < 2:
        sys.stderr.write(USAGE)
        return 2

    cfg = parse_kv(config_path())
    limit = geti(cfg, "limit_seconds", 7200)
    poll = max(1, geti(cfg, "poll_seconds", 5))

    st = rollover(load_state())

    # compute effective used "as of now"
    t = now()
    last = int(st.get("last", t))
    delta = t - last
    if delta < 0:
        delta = 0
    if delta > poll * 4:
        delta = poll * 4
    used = int(st.get("used", 0)) + delta

    remaining = max(0, limit - used)

    cmd = argv[1]
    if cmd == "remaining":
        if len(argv) >= 3 and argv[2] == "--s":
            print(int(remaining))
        else:
            print(hms(remaining))
        return 0

    if cmd == "status":
        print(f"remaining {hms(remaining)} (used {hms(used)} / {hms(limit)})")
        print("locked: yes (today)" if st.get("locked_date") == today() else "locked: no")
        return 0

    sys.stderr.write(USAGE)
    return 2

if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
