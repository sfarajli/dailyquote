#!/usr/bin/env python3
from __future__ import annotations
import os, time, json
from pathlib import Path
from typing import Dict

APP = "dailyquota"

def today() -> str:
    return time.strftime("%Y-%m-%d", time.localtime())

def now() -> int:
    return int(time.time())

def config_path() -> Path:
    xdg = os.environ.get("XDG_CONFIG_HOME")
    base = Path(xdg) if xdg else (Path.home() / ".config")
    return base / APP / "config.conf"

def state_path() -> Path:
    xdg = os.environ.get("XDG_DATA_HOME")
    base = Path(xdg) if xdg else (Path.home() / ".local" / "share")
    return base / APP / "state.json"

def parse_kv(path: Path) -> Dict[str, str]:
    if not path.exists():
        return {}
    out: Dict[str, str] = {}
    for line in path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        out[k.strip()] = v.strip()
    return out

def geti(d: Dict[str, str], k: str, default: int) -> int:
    try:
        return int(d.get(k, str(default)))
    except Exception:
        return default

def gets(d: Dict[str, str], k: str, default: str) -> str:
    v = d.get(k)
    return v if v is not None and v != "" else default

def atomic_write(path: Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    tmp = path.with_suffix(path.suffix + ".tmp")
    tmp.write_text(text, encoding="utf-8")
    os.replace(tmp, path)

def load_state() -> dict:
    p = state_path()
    if not p.exists():
        return {"date": today(), "used": 0, "last": now(), "locked_date": ""}
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        return {"date": today(), "used": 0, "last": now(), "locked_date": ""}

def save_state(st: dict) -> None:
    atomic_write(state_path(), json.dumps(st, indent=2) + "\n")

def rollover(st: dict) -> dict:
    if st.get("date") != today():
        return {"date": today(), "used": 0, "last": now(), "locked_date": ""}
    return st

def hms(sec: int) -> str:
    sec = max(0, int(sec))
    return f"{sec//3600:02d}:{(sec%3600)//60:02d}:{sec%60:02d}"

import subprocess

def poweroff(grace_seconds: int, action_cmd: str) -> None:
    print(f"Turning off in {grace_seconds} seconds", flush=True)
    time.sleep(max(0, grace_seconds))
    subprocess.run(action_cmd, shell=True)

def main() -> int:
    cfg = parse_kv(config_path())
    limit = geti(cfg, "limit_seconds", 7200)
    poll = max(1, geti(cfg, "poll_seconds", 5))
    grace = max(0, geti(cfg, "grace_seconds", 30))
    action = gets(cfg, "action_cmd", "sudo /sbin/poweroff")

    while True:
        # reload config so edits take effect without restart
        cfg = parse_kv(config_path())
        limit = geti(cfg, "limit_seconds", limit)
        poll = max(1, geti(cfg, "poll_seconds", poll))
        grace = max(0, geti(cfg, "grace_seconds", grace))
        action = gets(cfg, "action_cmd", action)

        st = rollover(load_state())

        # If locked for today, power off again after reboot (once X starts)
        if st.get("locked_date") == today():
            save_state(st)
            poweroff(grace, action)
            time.sleep(poll)
            continue

        t = now()
        last = int(st.get("last", t))
        # clamp delta to avoid huge jumps after suspend / clock changes
        delta = t - last
        if delta < 0:
            delta = 0
        if delta > poll * 4:
            delta = poll * 4

        st["used"] = int(st.get("used", 0)) + delta
        st["last"] = t
        save_state(st)

        if st["used"] >= limit:
            st["locked_date"] = today()
            save_state(st)
            poweroff(grace, action)
            time.sleep(poll)
            continue

        time.sleep(poll)

if __name__ == "__main__":
    raise SystemExit(main())
